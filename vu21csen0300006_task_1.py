# -*- coding: utf-8 -*-
"""VU21CSEN0300006 Task 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/143WDNZEqdXPznjMFYgFgKh81MnFGiSU9

8 PUZZLE
"""

from queue import PriorityQueue

goal_state = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 0]]

R = 3
C = 3

initial_state = []
print("Enter the entries rowwise:")
for i in range(R):
    a = []
    for j in range(C):
        a.append(int(input()))
    initial_state.append(a)
print("\n")

def manhattan_distance(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                row = (state[i][j] - 1) // 3
                col = (state[i][j] - 1) % 3
                distance += abs(i - row) + abs(j - col)
    return distance

class PuzzleNode:
    def __init__(self, state, parent=None, action=None):
        self.state = state
        self.parent = parent
        self.action = action
        self.cost = parent.cost + 1 if parent else 0
        self.heuristic = manhattan_distance(state)
        self.priority = self.cost + self.heuristic

    def __lt__(self, other):
        return self.priority < other.priority

def solve_puzzle(initial_state, goal_state):
    open_set = PriorityQueue()
    closed_set = set()
    initial_node = PuzzleNode(initial_state)
    open_set.put(initial_node)
    while not open_set.empty():
        current_node = open_set.get()
        if current_node.state == goal_state:
            solution_path = []
            while current_node:
                solution_path.append(current_node.state)
                current_node = current_node.parent
            return reversed(solution_path)

        closed_set.add(tuple(map(tuple, current_node.state)))
        row, col = next((i, j) for i in range(3) for j in range(3) if current_node.state[i][j] == 0)
        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dr, dc in moves:
            new_row, new_col = row + dr, col + dc
            if 0 <= new_row < 3 and 0 <= new_col < 3:
                new_state = [row[:] for row in current_node.state]
                new_state[row][col], new_state[new_row][new_col] = new_state[new_row][new_col], new_state[row][col]
                if tuple(map(tuple, new_state)) not in closed_set:
                    open_set.put(PuzzleNode(new_state, current_node, (dr, dc)))
    return None

solution_path = solve_puzzle(initial_state, goal_state)
if solution_path:
    for state in solution_path:
        for row in state:
            print(row)
        print()
    print("Solved!")
else:
    print("No solution found.")

"""WUMPUS WORLD"""

import random

class WumpusWorld:
    def __init__(self, size):
        self.size = size
        self.grid = [[' ' for _ in range(size)] for _ in range(size)]
        self.agent_location = (0, 0)
        self.wumpus_location = self.random_location()
        self.pit_locations = [self.random_location() for _ in range(3)]
        self.gold_location = self.random_location()

    def random_location(self):
        return random.randint(0, self.size - 1), random.randint(0, self.size - 1)

    def print_world(self):
        for i in range(self.size):
            for j in range(self.size):
                if (i, j) == self.agent_location:
                    print('A', end=' ')
                else:
                    print(self.grid[i][j], end=' ')
            print()
        print()

    def initialize_world(self):
        self.grid[self.wumpus_location[0]][self.wumpus_location[1]] = 'W'
        self.grid[self.gold_location[0]][self.gold_location[1]] = 'G'
        for pit_location in self.pit_locations:
            self.grid[pit_location[0]][pit_location[1]] = 'P'

    def move_agent(self, direction):
        x, y = self.agent_location
        if direction == 'UP' and x > 0:
            x -= 1
        elif direction == 'DOWN' and x < self.size - 1:
            x += 1
        elif direction == 'LEFT' and y > 0:
            y -= 1
        elif direction == 'RIGHT' and y < self.size - 1:
            y += 1

        self.agent_location = (x, y)
        self.grid[x][y] = 'A'

    def check_perceptions(self):
        x, y = self.agent_location
        if self.wumpus_location == (x, y):
            return "You smell a terrible odor!"
        for pit_location in self.pit_locations:
            if pit_location == (x, y):
                return "You feel a breeze!"
        if self.gold_location == (x, y):
            return "You see a glimmer of gold!"

        return "Nothing unusual."
size_of_world = 4
wumpus_world = WumpusWorld(size_of_world)
wumpus_world.initialize_world()

while True:
    wumpus_world.print_world()

    action = input("Enter your action (UP/DOWN/LEFT/RIGHT): ").upper()
    wumpus_world.move_agent(action)

    perception = wumpus_world.check_perceptions()
    print(perception)

    if wumpus_world.agent_location == wumpus_world.wumpus_location:
        print("You were eaten by the Wumpus! Game over.")
        break

    if wumpus_world.agent_location == wumpus_world.gold_location:
        print("Congratulations! You found the gold and won!")
        break

"""VACUUM CLEANER"""

def clean(floor):
  i, j, row, col = 0, 0, len(floor), len(floor[0])
  for i in range(row):
      if(i%2 == 0):
          for j in range(col):
              if(floor[i][j] == 1):
                  print_F(floor, i, j)
                  floor[i][j] = 0
              print_F(floor, i, j)
      else:
          for j in range(col-1, -1, -1):
              if(floor[i][j] == 1):
                  print_F(floor, i, j)
                  floor[i][j] = 0
              print_F(floor, i, j)
def print_F(floor, row, col):
    """A function to print the GRID , (row, col) represent the current vacuum cleaner position"""
    print("The Floor matrix is as below:")
    for r in range(len(floor)):
        for c in range(len(floor[r])):
            if r == row and c == col:
                print(f" >{floor[r][c]}< ", end = '')
            else:
                print(f"  {floor[r][c]}  ", end = '')
        print(end = '\n')
    print(end = '\n')
def main():
    floor = []
    m = int(input("Enter the No. of Rows: "))
    n = int(input("Enter the No. of Columns: "))
    print("Enter clean status for each cell (1 - dirty, 0 - clean)")
    for i in range(m):
        f = list(map(int, input().split(" ")))
        floor.append(f)
    print()
    clean(floor)
main()

